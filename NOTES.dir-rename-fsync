
Challenges with directory renames and fsync:
============================================

One of the general design goals for our fsync system call is to keep the amount
of dirty data written out to disk minimalistic; that is, we strive to flush out
only the dirty data that is associated with the file or directory being fsynced,
and nothing else, as much as possible.

However, there are situations where we will need to track dependencies between
directories and flush the dirty data associated with those dependent inodes as
well, in order to keep the on-disk filesystem structures consistent and to
preserve certain filesystem invariants.

Some of the important scenarios that come under this category are situations
where fsync() and rename() are involved. For example, when file renames are
involved, we explicitly track dependencies when fsyncing their parent
directories, to ensure that no combination of rename() and fsync() will ever
unintentionally delete files (or otherwise make them unreachable) on the disk.

One particularly challenging case involves fsync and directory renames. If we
aren't careful here, we can end up creating orphaned loops within the filesystem
directory hierarchy on the disk, breaking the filesystem's invariants!

It is straight-forward to avoid creating orphaned loops at the rename() system
call by inserting appropriate validity checks. However, there is a different,
rather subtle scenario, where the directory renames proceed successfully in
memory (maintaining the "no cycles" invariant in the in-memory directory
hierarchy), but a subsequent "minimalistic" fsync() can end up creating
orphaned loops on the disk as shown below.


Initial state on the disk:
--------------------------

A, B, C and D are directories.

          root (/)
           /
          /
         A
          \
           \
            B
           /
          /
         C
          \
           \
            D

The above directory tree is already on the disk. Now, we perform the following
directory renames:

Step 1: mv /A/B/C  /C
Step 2: mv /A/B    /C/D/B

Both these renames are valid, and they rearrange the directory tree in memory
as shown below.

             root (/)                       root (/)
              / \                            / \
             /   \                          /   \
Step 1 =>   A     C        Step 2 =>       A     C
             \     \                              \
              \     \                              \
               B     D                              D
                                                   /
                                                  /
                                                 B

Everything is good so far in memory and none of these changes have been written
to the disk yet. Now the user invokes fsync() on /C/D.

If fsync() strives to flush out the absolute minimum dirty data (corresponding
to the changes made only to directory D), then we'll end up with an orphaned
loop on the disk (even though the directory hierarchy in memory is just fine!)
as shown below:

          root (/)
           |
           |
           v
           A

      +----> C ----+
      |            |
      B            |
      ^            |
      |            v
      + ---------- D

The trouble is that the "minimal flush" doesn't quite capture enough of the
recent structural changes to the directory hierarchy - in particular, directory
B still thinks that C is its sub-directory, when in reality C has been made an
ancestor of B! That creates the loop. Also, since C was reachable only via B
(/A/B/C) in the original hierarchy, and we happened to erase the crucial A->B
link in the process of moving B into C, we lose access to C from the root (/).
This causes the loop to get disconnected and turn into an orphaned loop!


Now, let's try to analyze how we managed to get ourselves entangled this way.

Looking closer, the moves can be described pictorially like this:

          root (/)
           /
          /
         A
          \
           \
            B  (Ancestor)
           /
         ^^^^^ <---- CUT
          /
         C
          \
           \
            D  (Descendant)


We can generalize this figure to:


          root (/)
           /
          /
         A
          \
           \
            B  (Ancestor)
           /
           .
           .
           .
         ^^^^^ <---- CUT
           .
           .
           .
          /
         X
          \
           \
            Y  (Descendant)
           /
          /
         Z

We can see that this represents the following two deliberate actions:

1. Pick an ancestor and a descendant, and perform a cut somewhere in between
   them. Move the bottom portion of the cut away and attach it elsewhere,
   such that the ancestor we chose earlier is no longer an ancestor of the
   chosen descendant, in the resultant tree.

   Thus, after this step, any directory (*) in the upper portion of the cut
   can be moved into any directory in the lower portion of the cut.

   (*) More precisely, any directory that is not a new ancestor of the
       bottom portion of the cut, after that portion has been attached
       somewhere.

2. Move the originally chosen ancestor into the originally chosen descendant.

Note that the rename system call will allow step 2 to proceed in memory,
only because it happens after the cut operation. Otherwise, it would
immediately violate the filesystem's "no cycles" invariant.

The directory hierarchy in memory is fine so far. But we can trick the
filesystem into causing a loop on the disk if we manage to make fsync skip
step 1 and flush only the changes made in step 2. In other words, invoke
fsync() on either the descendant (Y), or on the ancestor's parent (A),
because those are the only 2 directories (source and destination) that
were dirtied in step 2.


Proposed solution:
------------------

Considering the above analysis, the solution to this problem is quite clear:
don't let fsync skip step 1 (i.e., flushing the cut) under any circumstance.
In other words, irrespective of which directory the fsync() is invoked on,
first go find the cut and flush it out, and only then flush the directory
being fsynced.

But here is another, simpler way to look at this: given a directory D to be
fsynced, consider the set of directories on the path going from the root to D,
in the in-memory filesystem hierarchy (i.e., the ancestors of D). We just need
to ensure that flushing out changes to D will not trick us into moving one of
D's ancestor's into D. So, if we flush out the in-memory path from root to D
to the disk before flushing out the changes to D itself, we can rest assured
that none of the (new) ancestors of D will be moved into D during that latter
flush. This is the core idea behind our fsync algorithm, which is described
below in detail.

Given a directory to be fsynced (say A), check if either a sub-directory was
moved away from it or some directory was moved into it. Then find the
destination (parent directory) (Y) for that rename (if the given directory
was not the destination already). This can be trivially achieved using the
information captured in the rename operation logged in the oplog.

From the destination directory (Y), go recursively up the directory hierarchy
in memory, all the way upto the root, and note down all directories on that
path that are dirty. Then, starting from the root, do the following for each
dirty directory in our list:

o If the dirty directory being considered is E and its sub-directory (along
  the path from root to Y) is F, then:

  o If F's move into E is yet to be flushed, flush all E's changes (in
     timestamp order) upto and including the operation that adds F into E on
     the disk. And nothing more! That is, if E has more operations to be
     flushed after this point, skip them. (**)

     If any of these operations are directory renames that move a sub-directory
     out of E, then run this whole fsync algorithm from the beginning
     recursively at the destination directory for that rename. (***)

     Once F is made persistent as E's child on the disk, go to the next
     iteration of this loop.

Repeat this until the path from root to Y is made persistent on the disk.
Then, flush all the operations modifying directory Y (including renames).

This guarantees that we will never form an (orphaned) loop on the disk, no
matter where fsync is invoked and which directories are involved in renames.

(**)  If we do a full flush of every dirty directory from root to D, scenarios
      like example 4 below will end up in a loop on the disk immediately.
      Hence, we need to have precise control over how much we flush at each
      stage.

(***) If we are not careful, flushing a directory rename that moves a
      sub-directory away from E, can cause a loop in a different sub-tree,
      while we are busy trying to avoid loops in the given sub-tree! That's why
      it is important to re-run the entire loop-avoidance algorithm for that
      directory-rename recursively.


(Semi-formal) Proof of correctness for this algorithm:
------------------------------------------------------

Theorem: The above algorithm prevents (orphaned) loops from getting formed
in the filesystem hierarchy on the disk due to fsync.

(Assumption: The rename system call does not allow loops to be formed in
the directory hierarchy in memory.)

Proof: We prove this by contradiction.

Let us assume (for contradiction) that a loop is formed on the disk due to
fsync. So there must be some specific (single) directory move which introduces
the loop: that is, there was no loop on the disk before that rename, but
there is a loop immediately after executing that rename on the disk.

                    root
                     |
                     v
                     A
                     |
                     v
           +-------> B
           |         |
           |         v
           |         C
           |         |
           |         v
    Loop   |         .
           |         .
           |         .
           |         v
           |         K
           |         |
           |         v
           +-------- L

Let's identify that loop-causing directory rename as the operation which does:

  mv (B, L/B). (This adds the link from L to B above, forming the loop).


Since this link was flushed to disk (causing the loop), it follows that fsync
should have been invoked on either L or the original parent of B, i.e., A.
(Incidentally this also causes the loop to get disconnected from A, making it
an orphaned loop).


Lemma 1: There is at least one cut in the directory chain extending from B to
         L, in memory.

Proof of Lemma 1: If the directory chain from B to L was uncut (in memory),
then moving B into L would form a loop in memory itself! But by the assumption
above, we know that the rename system call would prevent this. Hence, there is
at least one cut between B and L, which makes the rename of B into L valid
(in memory).


Lemma 2: Our fsync algorithm will find the cut (at least one of the cuts) and
         flush it out before flushing anything else.

Proof of Lemma 2: Our algorithm first trivially identifies the destination
of the rename, namely L, and then goes recursively up the in-memory directory
tree from L, until it finds a directory which is dirty and had another directory
recently moved into it. So, it goes searching upwards from L, potentially all
the way upto the root. But since there is only one way to go to the root from
L, it has to pass through the chain between L and B, and we already established
in Lemma 1 that there is at least one cut between L and B. Thus, it is certain
that our algorithm will find that cut. (In the degenerate case, B has a direct
link to L in the original tree, in which case, B->L is itself the point of the
cut, and thus fsync would have been invoked directly on the cut itself, thus
trivially proving Lemma 2).

Now that Lemma 2 is proved, let G->H be the first point of cut that our
algorithm encounters.

Our algorithm specifies that we flush the cut to disk first, before anything
else. This means that H will be moved away from G into some other directory,
such that G will no longer be an ancestor of H.

Hence, after this flush, B is no longer an ancestor of L on the disk (because
of the cut which has been made persistent on the disk).

Thus, before we add the L->B link on the disk (which was supposed to form the
"loop"), we have already broken the chain in the other direction on the disk
(extending from B to L).

Therefore, adding the L->B link does not cause a loop on the disk! This
contradicts our assumption above that L->B is the link which causes the loop.
Hence, our higher-level assumption that fsync causes a loop on the disk must
be wrong. Hence proved!!! :-)

Note: It is easy to see that we just need to find *a* cut and flush it, (rather
than all the cuts, in case there are more), in order to avoid loops.

(Further, it is not hard to show that a loop always implies an orphaned loop.
Thus, our algorithm prevents orphaned loops as well).


Now that we have proved our algorithm for the simple case, let's try to prove
that it works in more complicated situations as well.

Lemma 3: Flushing the cut referred to in Lemma 2 will not cause loops anywhere
in the filesystem tree.

Our algorithm has been augmented to deal with situations where the cut that
we found (G->H), if flushed (i.e., H moved to a different directory), will be
the loop-causing link (equivalent to L->B) in a different part of the filesystem
tree. The key idea behind our solution is to recursively run our algorithm
from the beginning, at the cut that we found (G), until we reach the very first
(related) cut, and only then start flushing the renames (accumulated via
recursion) to disk (which will naturally flush them out in the right order).

Proving this is rather simple: Suppose that flushing the cut that we found,
causes a loop somewhere else in the filesystem tree. This implies that, that
particular loop has its own, different point of cut further up the tree, which
has not yet been flushed (which is why it results in a loop). But our algorithm
recursively finds all the related cuts, searching all the way upto the root
if necessary, and doesn't start flushing any rename operation until the
recursion stops -- which implies that there are no more (related) cuts to
be found. Thus, our assumption that there is yet another related cut to be
found, must be wrong. This proves Lemma 3 by contradiction.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Below are a few sample scenarios on which this algorithm has been simulated
just to make sure that it works:

Example 1:
==========

A-D are directories. /A/B/C/D exists on the disk.

Perform the following directory renames:

Step 1: mv /A/B/C  /C
Step 2: mv /A      /C/A
Step 3: mv /C/A/B  /C/D/B

Then fsync /C/D. Verify that it doesn't cause the orphaned loop C->D->B->C.

Example 2:
==========

A-J are directories. /A/B/C/D/E/F/G/H/I/J exists on the disk.

Perform the following directory renames:

Step 1: mv /A/B/C/D/E/F/G  /G
Step 2: mv /A/B/C          /G/C
Step 3: mv /G/C/D/E/F      /G/H/I/J/F

Then fsync /G/H/I/J. Verify that it doesn't cause the orphaned loop
G->H->I->J->F->G.

Example 3:
==========

A-F are directories. /A/B/C/D/E/F exists on the disk.

Perform the following directory renames:

Step 1: mv /A/B/C/D   /D
Step 2: mv /A/B       /D/E/F/B

Then fsync /D/E/F. Verify that it doesn't cause the orphaned loop
C->D->E->F->B->C.


Example 4: Preventing loops in one sub-tree can cause a loop in another
=======================================================================

A-P are directories. /A/B/C/D/E/F/G/H/I/J and /A/B/C/D/E/F/G/H/K/L/M/N/O/P
exist on the disk. (Note that H has 2 sub-trees).

Perform the following directory renames:

Step 1: mv /A/B/C/D/E/F/G/H/K/L/M    /A/B/M
Step 2: mv /A/B/C/D/E/F/G/H          /A/B/M/N/O/P/H
Step 3: mv /A/B/C                    /A/B/M/N/O/P/H/I/J/C

Then,
a. fsync /A/B/M/N/O/P/H/I/J  (this is the complicated case).
   Verify that it doesn't cause the orphaned loop C->D->E->F->G->H->I->J->C
   or the orphaned loop K->L->M->N->O->P->H->K

b. Alternatively, as a different (simpler) exercise, fsync /A/B/M/N/O/P instead.
   Verify that it doesn't cause the orphaned loop K->L->M->N->O->P->H->K


Example 5: Flushing dependent renames in timestamp order is not always safe
===========================================================================

A-H are directories. /A/B/C/D/E/F/G/H exists on the disk.

Perform the following directory renames:

Step 1: mv /A/B/C/D/E   /A/E          (i.e., move E from D to A)
Step 2: mv /A/B/C       /A/E/F/G/H/C  (i.e., move C from B to H)
Step 3: mv /A/E/F/G     /G            (i.e., move G from F to /)

Then fsync /G/H. Verify that it doesn't cause the orphaned loop
H->C->D->E->F->G->H.

Here is the tricky part:

a. Either Step 1 or Step 3 can make Step 2 valid. That is, both of them can
   serve as the "cut" (even though Step 3 occurred after Step 2).

b. In order to track down dependencies for Step 2, if we go up the final
   in-memory tree starting from /G/H and go up to the root, then we will only
   find root as the dirty directory (thus pointing at Step 3); in particular,
   we will never be able to find Step 1, because directory A is no longer an
   ancestor of G.

   Now, if we order these 2 steps in timestamp order, we get (Step 2, Step 3),
   but flushing them out in that order will cause a loop on the disk right after
   Step 2! So the correct order to flush them is actually (Step 3, Step 2), even
   though this is not the timestamp order!


Example 6: Ancestor-Descendant relationships are not rigid
==========================================================

A-H are directories. /A/B/C/D/E/F/G/H exists on the disk.

Perform the following directory renames:

[ Initially C is an ancestor of H ]

Step 1: mv /A/B/C/D/E   /E
Step 2: mv /E/F/G       /G
Step 3: mv /A/B/C       /G/H/C       [ Now C is a descendant of H ]
Step 4: mv /G/H/C       /C
Step 5: mv /G           /C/D/G       [ Now C is an ancestor of H again ]
Step 6: mv /A/B         /C/D/G/H/B

Then fsync /C/D/G/H. Verify that it doesn't cause the orphaned loop
C->D->G->H->C.

An fsync algorithm that tries to keep track of ancestor-descendant relationships
across directories can get really complicated in such scenarios and can be
very hard to get right.

Also, note that H is dirty and 2 of its transactions are: rename C into H, and
rename C out of H (and into root). We can't really absorb them because they
rename C from and to different directories overall (B and root). Avoiding loops
in this scenario needs accurate tracking of the dependent renames and precise
control over the partial flushes at each dependent dirty directory (root, D and
H).

