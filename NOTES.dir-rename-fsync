
Challenges with directory renames and fsync:
============================================

One of the general design goals for our fsync system call is to keep the amount
of dirty data written out to disk minimalistic; that is, we strive to flush out
only the dirty data that is associated with the file or directory being fsynced,
and nothing else, as much as possible.

However, there are situations where we will need to track dependencies between
directories and flush the dirty data associated with those dependent inodes as
well, in order to keep the on-disk filesystem structures consistent and to
preserve certain filesystem invariants.

Some of the important scenarios that come under this category are situations
where fsync() and rename() are involved. For example, when file renames are
involved, we explicitly track dependencies when fsyncing their parent
directories, to ensure that no combination of rename() and fsync() will ever
unintentionally delete files (or otherwise make them unreachable) on the disk.

One particularly challenging case involves fsync and directory renames. If we
aren't careful here, we can end up creating orphaned loops within the filesystem
directory hierarchy on the disk, breaking the filesystem's invariants!

It is straight-forward to avoid creating orphaned loops at the rename() system
call by inserting appropriate validity checks. However, there is a different,
rather subtle scenario, where the directory renames proceed successfully in
memory (maintaining the "no cycles" invariant in the in-memory directory
hierarchy), but a subsequent "minimalistic" fsync() can end up creating
orphaned loops on the disk as shown below.


Initial state on the disk:
--------------------------

A, B, C and D are directories.

          root (/)
           /
          /
         A
          \
           \
            B
           /
          /
         C
          \
           \
            D

The above directory tree is already on the disk. Now, we perform the following
directory renames:

Step 1: mv /A/B/C  /C
Step 2: mv /A/B    /C/D/B

Both these renames are valid, and they rearrange the directory tree in memory
as shown below.

             root (/)                       root (/)
              / \                            / \
             /   \                          /   \
Step 1 =>   A     C        Step 2 =>       A     C
             \     \                              \
              \     \                              \
               B     D                              D
                                                   /
                                                  /
                                                 B

Everything is good so far in memory and none of these changes have been written
to the disk yet. Now the user invokes fsync() on /C/D.

If fsync() strives to flush out the absolute minimum dirty data (corresponding
to the changes made only to directory D), then we'll end up with an orphaned
loop on the disk (even though the directory hierarchy in memory is just fine!)
as shown below:

          root (/)
           |
           |
           v
           A

      +----> C ----+
      |            |
      B            |
      ^            |
      |            v
      + ---------- D

The trouble is that the "minimal flush" doesn't quite capture enough of the
recent structural changes to the directory hierarchy - in particular, directory
B still thinks that C is its sub-directory, when in reality C has been made an
ancestor of B! That creates the loop. Also, since C was reachable only via B
(/A/B/C) in the original hierarchy, and we happened to erase the crucial A->B
link in the process of moving B into C, we lose access to C from the root (/).
This causes the loop to get disconnected and turn into an orphaned loop!


Now, let's try to analyze how we managed to get ourselves entangled this way.

Looking closer, the moves can be described pictorially like this:

          root (/)
           /
          /
         A
          \
           \
            B  (Ancestor)
           /
         ^^^^^ <---- CUT
          /
         C
          \
           \
            D  (Descendant)


We can generalize this figure to:


          root (/)
           /
          /
         A
          \
           \
            B  (Ancestor)
           /
           .
           .
           .
         ^^^^^ <---- CUT
           .
           .
           .
          /
         X
          \
           \
            Y  (Descendant)
           /
          /
         Z

We can see that this represents the following two deliberate actions:

1. Pick an ancestor and a descendant, and perform a cut somewhere in between
   them. Move the bottom portion of the cut away and attach it elsewhere,
   such that the ancestor we chose earlier is no longer an ancestor of the
   chosen descendant, in the resultant tree.

   Thus, after this step, any directory (*) in the upper portion of the cut
   can be moved into any directory in the lower portion of the cut.

   (*) More precisely, any directory that is not a new ancestor of the
       bottom portion of the cut, after that portion has been attached
       somewhere.

2. Move the originally chosen ancestor into the originally chosen descendant.

Note that the rename system call will allow step 2 to proceed in memory,
only because it happens after the cut operation. Otherwise, it would
immediately violate the filesystem's "no cycles" invariant.

The directory hierarchy in memory is fine so far. But we can trick the
filesystem into causing a loop on the disk if we manage to make fsync skip
step 1 and flush only the changes made in step 2. In other words, invoke
fsync() on either the descendant (Y), or on the ancestor's parent (A),
because those are the only 2 directories (source and destination) that
were dirtied in step 2.


Proposed solution:
------------------

Considering the above analysis, the solution to this problem is quite clear:
don't let fsync skip step 1 (i.e., flushing the cut) under any circumstance.
In other words, irrespective of which directory the fsync() is invoked on,
first go find the cut and flush it out, and only then flush the directory
being fsynced.

But here is another, simpler way to look at this: given a directory D to be
fsynced, consider the set of directories on the path going from the root to D,
in the in-memory filesystem hierarchy (i.e., the ancestors of D). We just need
to ensure that flushing out changes to D will not trick us into moving one of
D's ancestor's into D. So, if we flush out the in-memory path from root to D
to the disk before flushing out the changes to D itself, we can rest assured
that none of the (new) ancestors of D will be moved into D during that latter
flush. This is the core idea behind our fsync algorithm, which is described
below in detail.

Given a directory to be fsynced (say A), check if either a sub-directory was
moved away from it or some directory was moved into it. Then find the
destination (parent directory) (Y) for that rename (if the given directory
was not the destination already). This can be trivially achieved using the
information captured in the rename operation logged in the oplog.

From the destination directory (Y), go recursively up the directory hierarchy
in memory, all the way upto the root, and note down all directories on that
path that are dirty. Then, starting from the root, do the following for each
dirty directory in our list:

o If the dirty directory being considered is E and its sub-directory (along
  the path from root to Y) is F, then:

  o If F's move into E is yet to be flushed, flush all E's changes (in
     timestamp order) upto and including the operation that adds F into E on
     the disk. And nothing more! That is, if E has more operations to be
     flushed after this point, skip them. (**)

     If any of these operations are directory renames that move a sub-directory
     out of E, then run this whole fsync algorithm from the beginning
     recursively at the destination directory for that rename. (***)

     Once F is made persistent as E's child on the disk, go to the next
     iteration of this loop.

Repeat this until the path from root to Y is made persistent on the disk.
Then, flush all the operations modifying directory Y (including renames).

This guarantees that we will never form an (orphaned) loop on the disk, no
matter where fsync is invoked and which directories are involved in renames.

(**)  If we do a full flush of every dirty directory from root to D, scenarios
      like example 4 below will end up in a loop on the disk immediately.
      Hence, we need to have precise control over how much we flush at each
      stage.

(***) If we are not careful, flushing a directory rename that moves a
      sub-directory away from E, can cause a loop in a different sub-tree,
      while we are busy trying to avoid loops in the given sub-tree! That's why
      it is important to re-run the entire loop-avoidance algorithm for that
      directory-rename recursively.


(Semi-formal) Proof of correctness for this algorithm:
------------------------------------------------------

Our fsync loop-avoidance algorithm can be summarized as follows:

Given a directory D to be fsynced:

Step 1: Build a list of its ancestors as seen in the in-memory filesystem tree,
        and flush out the links forming the path from root to D, one after
        another, starting from the root. After this completes, the path from
        root to D on the disk will be exactly the same as the path from root to
        D in memory. In other words, D will have the same ancestors on the
        disk as it has in memory.

Step 2: Then, flush the changes to D onto the disk.

Theorem: The above algorithm prevents (orphaned) loops from getting formed
in the filesystem hierarchy on the disk due to fsync.

(Assumption: The rename system call does not allow loops to be formed in
the directory hierarchy in memory.)

Proof:

There are only 2 cases to consider here: either Step 1 causes the loop
or Step 2 causes the loop. We first show that Step 2 doesn't cause a loop
and then use it to prove that Step 1 also doesn't cause a loop; which implies
that the fsync algorithm as a whole doesn't cause loops on the disk.

Lemma 1: Step 2 in the fsync algorithm doesn't cause a loop on the disk.

Consider a dirty directory D to be fsynced. The interesting case is when D's
modifications include one or more rename operations that move other directories
into D. Let's consider one such rename operation, which moves some directory E
into D.

                         root
                           |
                           .
                           .
                           |
                           v
                           D
                           :
                           :
                           v
                           E

So, fsync will have to add the link to E within D, on the disk. We know that
the only way to cause a cycle in the filesystem tree is to move (rename)
directories such that an ancestor gets moved into a descendant. Thus, for
fsync to cause a loop on the disk by moving E into D, E must be an ancestor
of D on the disk, just before this step.

We know that Step 1 in our fsync algorithm ensures that the ancestors of D on
the disk are exactly the same as the ancestors of D in memory, before moving
anything (E) into D. This implies that, for fsync to cause a loop, E must be
an ancestor of D in memory too! But that in turn implies that there must be a
loop in the in-memory filesystem hierarchy! This contradicts our assumption
above that the rename system call does not allow loops to be formed in memory.

Hence, it follows that if there are no loops in memory, fsync will not introduce
any loops on the disk, because it will propagate the same set of ancestors (of
the directory being fsynced) to disk, before flushing the changes associated
with that directory. Hence proved (Lemma 1).


Lemma 2: Step 1 in the fsync algorithm doesn't cause a loop on the disk.

Interestingly, Step 1 applied at D can be described as the sequence of Step 1
and Step 2 applied at D's parent (with the small modification that changes to
D's parent are flushed in Step 2 in timestamp order only upto and including the
operation that adds the link to D within D's parent, and none of the subsequent
changes).

Taking this further, we can view Step 1 at D's parent as being Step 1 and
Step 2 applied at D's grandparent, and so on. This recursion extends all the way
upto the root, where Step 1 is unnecessary because the root directory already
exists on the disk. In other words, Step 2 at the root doesn't require Step 1
as a prerequisite.

So, in effect, the fsync algorithm is nothing but a sequence of Step 2's applied
on each directory on the path from root to D. (Note that we have eliminated
Step 1 from the equation by showing how it can be decomposed into Step 2).
And we already know from Lemma 1 that Step 2 doesn't cause a loop. Hence, it
follows that Step 1 also doesn't cause loops, because it is just a whole bunch
of Step 2's run one after another. Hence proved (Lemma 2).

Since our fsync algorithm only consists of Step 1 and Step 2, and we have proved
that neither of them causes a loop (using Lemmas 1 and 2), it follows that the
fsync algorithm as a whole doesn't cause loops on the disk. Hence proved!


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Below are a few sample scenarios on which this algorithm has been simulated
just to make sure that it works:

Example 1:
==========

A-D are directories. /A/B/C/D exists on the disk.

Perform the following directory renames:

Step 1: mv /A/B/C  /C
Step 2: mv /A      /C/A
Step 3: mv /C/A/B  /C/D/B

Then fsync /C/D. Verify that it doesn't cause the orphaned loop C->D->B->C.

Example 2:
==========

A-J are directories. /A/B/C/D/E/F/G/H/I/J exists on the disk.

Perform the following directory renames:

Step 1: mv /A/B/C/D/E/F/G  /G
Step 2: mv /A/B/C          /G/C
Step 3: mv /G/C/D/E/F      /G/H/I/J/F

Then fsync /G/H/I/J. Verify that it doesn't cause the orphaned loop
G->H->I->J->F->G.

Example 3:
==========

A-F are directories. /A/B/C/D/E/F exists on the disk.

Perform the following directory renames:

Step 1: mv /A/B/C/D   /D
Step 2: mv /A/B       /D/E/F/B

Then fsync /D/E/F. Verify that it doesn't cause the orphaned loop
C->D->E->F->B->C.


Example 4: Preventing loops in one sub-tree can cause a loop in another
=======================================================================

A-P are directories. /A/B/C/D/E/F/G/H/I/J and /A/B/C/D/E/F/G/H/K/L/M/N/O/P
exist on the disk. (Note that H has 2 sub-trees).

Perform the following directory renames:

Step 1: mv /A/B/C/D/E/F/G/H/K/L/M    /A/B/M
Step 2: mv /A/B/C/D/E/F/G/H          /A/B/M/N/O/P/H
Step 3: mv /A/B/C                    /A/B/M/N/O/P/H/I/J/C

Then,
a. fsync /A/B/M/N/O/P/H/I/J  (this is the complicated case).
   Verify that it doesn't cause the orphaned loop C->D->E->F->G->H->I->J->C
   or the orphaned loop K->L->M->N->O->P->H->K

b. Alternatively, as a different (simpler) exercise, fsync /A/B/M/N/O/P instead.
   Verify that it doesn't cause the orphaned loop K->L->M->N->O->P->H->K


Example 5: Flushing dependent renames in timestamp order is not always safe
===========================================================================

A-H are directories. /A/B/C/D/E/F/G/H exists on the disk.

Perform the following directory renames:

Step 1: mv /A/B/C/D/E   /A/E          (i.e., move E from D to A)
Step 2: mv /A/B/C       /A/E/F/G/H/C  (i.e., move C from B to H)
Step 3: mv /A/E/F/G     /G            (i.e., move G from F to /)

Then fsync /G/H. Verify that it doesn't cause the orphaned loop
H->C->D->E->F->G->H.

Here is the tricky part:

a. Either Step 1 or Step 3 can make Step 2 valid. That is, both of them can
   serve as the "cut" (even though Step 3 occurred after Step 2).

b. In order to track down dependencies for Step 2, if we go up the final
   in-memory tree starting from /G/H and go up to the root, then we will only
   find root as the dirty directory (thus pointing at Step 3); in particular,
   we will never be able to find Step 1, because directory A is no longer an
   ancestor of G.

   Now, if we order these 2 steps in timestamp order, we get (Step 2, Step 3),
   but flushing them out in that order will cause a loop on the disk right after
   Step 2! So the correct order to flush them is actually (Step 3, Step 2), even
   though this is not the timestamp order!


Example 6: Ancestor-Descendant relationships are not rigid
==========================================================

A-H are directories. /A/B/C/D/E/F/G/H exists on the disk.

Perform the following directory renames:

[ Initially C is an ancestor of H ]

Step 1: mv /A/B/C/D/E   /E
Step 2: mv /E/F/G       /G
Step 3: mv /A/B/C       /G/H/C       [ Now C is a descendant of H ]
Step 4: mv /G/H/C       /C
Step 5: mv /G           /C/D/G       [ Now C is an ancestor of H again ]
Step 6: mv /A/B         /C/D/G/H/B

Then fsync /C/D/G/H. Verify that it doesn't cause the orphaned loop
C->D->G->H->C.

An fsync algorithm that tries to keep track of ancestor-descendant relationships
across directories can get really complicated in such scenarios and can be
very hard to get right.

Also, note that H is dirty and 2 of its transactions are: rename C into H, and
rename C out of H (and into root). We can't really absorb them because they
rename C from and to different directories overall (B and root). Avoiding loops
in this scenario needs accurate tracking of the dependent renames and precise
control over the partial flushes at each dependent dirty directory (root, D and
H).

